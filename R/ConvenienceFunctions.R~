#
# 2014-12-12 Time Series Convenience functions
# 


#' Subsampling and Interpolating Oversampled Time Series
#' 
#' Subsample and interpolate oversampled or undersampled time series to obtain
#' equidistant data at a lower or higher sampling frequency
#' 
#' 
#' @param x Data frame with time in first column and time series data in
#' second. Time column should be of POSIXt class
#' @param dt The desired sampling interval. Can be smaller or larger than
#' interval between original samples. dt can be a difftime object, or a numeric
#' when "units" is provided
#' @param units Unit of dt
#' @return A data frame with time and subsampled and/or interpolated time
#' series. \code{time} is a vector of increasing times (POSIXct) at regular
#' intervals \code{dt}, starting at the first time in the original data frame.
#' The resulting time series is obtained by interpolating the original data at
#' those times.
#' @aliases resample
#' @author Tom Cox <tom.cox@@uantwerp.be>
#' @keywords utilities
#' 
#'  
#' @export subsample
subsample <- function(x, dt, units=NULL){
# subsample and interpolate to obtain equidistant data
# x = data frame with 2 columns, time and parameter


if (!inherits(dt,"difftime")){
if (is.null(units)) {
  stop("Either provide dt as difftime object, or provide units of dt")
} else {
  dt <- as.difftime(dt, units=units)
}
}

if (dim(x)[1]<2) 
{return(x)
} else {

trange <- range(x[,1])
Nsample <- unclass(difftime(trange[2], trange[1], units=units(dt)))%/%unclass(dt)
tsub <- trange[1] + (0:(Nsample-1))*dt
xsub <- data.frame(time=tsub,approx(x[,1],x[,2],tsub)$y)
names(xsub) <- names(x)
return(xsub)}

}

#' @rdname subsample
#' @export resample
resample <- function(x, dt, units=NULL){
subsample(x=x,dt=dt, units=units)
}


#
# Gap Filling
#



#' Fill Gaps in Time Series
#' 
#' Fill gaps in time series by linear interpolation
#' 
#' 
#' @param x Data frame with time in first column and time series data in
#' second. Time column should be of POSIXt class
#' @param type Type of interpolation. Only linear interpolation implemented
#' @return A data frame with time and interpolated time series.
#' @author Tom Cox <tom.cox@uantwerp.be>
#' @keywords utilities
#' @examples
#' 
#' 
#' 
#' @export gapfill
gapfill <- function(x, type="linear") {
 
if (!type=="linear") stop("Only linear interpolation implemented")

t <- x[,1]
y <- x[,2]

if (length(y)>1){
 dt <- t[2] - t[1]
 times <- seq(t[1],t[length(t)],dt)

 if(all(is.na(y))){
  yfilled <- rep(NA, length(times))
  } else {
  yfilled <- approx(t,y,times)$y 
  }

} else {
yfilled <- y
times <- t
}
return(data.frame(t=times,y=yfilled))
}


#
# Increase resolution of fft by padding zeroes behind the series
#



#' Fourier transform of padded time series
#' 
#' Fourier transform of padded time series
#' 
#' 
#' @param x Time series for which fourier transform (fft) is calculated after
#' padding with zeroes
#' @param n Number of zeroes to be padded
#' @return Fourier transform of x padded with n zeroes
#' @author Tom Cox <tom.cox@uantwerp.be>
#' @keywords utilities
#' @export paddedfft
paddedfft<- function(x, # series to be fourier transformed (fft)
                      n # number of zeros to be padded
                      )
{
x2 <- x - mean(x)
x2<- c(x2,rep(0,n))
fx2 <- fft(x2)
return(fx2 # Fourier transform of x padded with n zeroes
        )
}



# 2013-05-22 add functionality to return the trend. Should be backward compatible
# Old version of detrend below


#' Detrend a vector
#' 
#' Substract a linear trend from a vector
#' 
#' The linear trend is calculated as \code{lm(y~1:length(y))}
#' 
#' @param y Vector or time series to be detrended
#' @param returntrend When FALSE the detrended vector is
#' returned, when TRUE a 2 element list is returned with both the trend and the
#' detrended vector
#' @return The detrended vector. When \code{returntrend = TRUE} a 2 element
#' list is returned with the trend and the detrended vector.
#' @author Tom Cox <tom.cox@uantwerp.be>
#' @keywords utilities
#' @export detrend
detrend <- function(y, returntrend = FALSE){
x <- 1:(length(y))
trendmod <- lm(y~x)
trend <- predict(trendmod)

if (returntrend) {
return(list(detrended=y-trend, trend=trend))
} 
else {
return(y-trend)
}
}

# Old version of detrend
# detrend <- function(y, returntrend = FALSE){
# x <- 1:(length(y))
# trendmod <- lm(y~x)
# trend <- predict(trendmod)
# return(y-trend)
# }
